# 23장 실행 컨텍스트

# 실행 컨텍스트 execution context

- 자바스크립트의 동작원리를 담고 있는 핵심 개념이다.
- 실행 컨텍스트를 바르게 이해하면 이해할 수 있는 것
  - 스코프를 기반으로 식별자와 식별자에 바인딩 된 값을 관리하는 방식
  - 호이스팅이 발생하는 이유
  - 클로저의 동작 방식
  - 태스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식

## 23.1 소스코드의 타입

- 소스코드는 실행 컨텍스트를 생성한다.
- 소스코드를 구분하는 이유는 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.

### 소스코드의 타입

- 전역 코드
  - 전역에 존재하는 소스코드
  - 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
- 함수 코드
  - 함수 내부에 존재하는 소스코드
  - 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
- eval 코드
  - 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
- 모듈 코드
  - 모듈 내부에 존재하는 소스코드
  - 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.

### 전역 코드

- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다.
- 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.

### 함수 코드

- 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다.
- 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
- 함수 코드가 평가되면 실행 컨텍스트가 생성된다.

### eval 코드

- eval 코드는 strict mode에서 자신만의 독자적인 스코프를 생성한다.
- eval 코드가 평가되면 실행 컨텍스트가 생성된다.

### 모듈 코드

- 모듈별로 독립적인 모듈 스코프를 생성한다.
- 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

## 23.2 소스코드의 평가와 실행

- 모든 소스 코드는 실행에 앞서 평가 과정을 거치며 실행하기 위한 준비를 한다.
- 자바스크립트 엔진은 소스코드를 “소스코드 평가”와 “소스코드 실행”과정으로 나누어 처리한다.

### 소스코드 평가 과정

1. 실행 컨텍스트를 생성
2. 변수, 함수 등의 선언문만 먼저 실행
3. 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록

### 소스코드 실행

- 소스코드 평가 과정이 끝나면 비로소 런타임이 시작된다.
- 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에 검색해서 취득한다.
- 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.

```jsx
var x
x = 1
```

- 위 예제를 2개의 과정으로 나누어 처리한다.
  - 소스코드 평가 과정
    - 소스코드 평가 과정에서 변수 선언문 `var x;`를 먼저 실행한다.
    - 변수 식별자 `x`는 실행 컨텍스트가 관리하는 스코프에 등록되고 `undifined`로 초기화된다.
  - 소스코드 실행 과정
    - 변수 할당문 `x = 1;`이 실행된다.
    - 이 때 `x` 변수에 값을 할당하려면 먼저 `x` 변수가 선언된 변수인지 확인해야 한다.
      - 이를 위해 실행컨텍스트가 관리하는 스코프에 `x` 변수가 등록되어 있는지 확인한다.
    - `x` 변수가 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리한다.

## 23.3 실행 컨텍스트의 역할

### 1. 전역 코드 평가

- 전역 코드를 실행하기에 앞서 먼저 전역 코드 평가 과정을 거친다.
- 변수 선언문과 함수 선언문이 먼저 실행된다.
- 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다.
  - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.

### 2. 전역 코드 실행

- 전역 코드 평가 과정이 끝나면 런티암이 시작되어 전역 코드가 순차적으로 실행된다.
- 전역 변수에 값이 할당되고 함수가 호출된다.
  - 함수가 호출되면 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.

### 3. 함수 코드 평가

```jsx
const x = 1;
const y = 2;

function foo(a) {
	canst x = 10;
	canst y = 20;

	console.log(a + x + y);
}

foo(100);

console.log(x + y);
```

- 함수 코드 평가 과정을 거친다.
- 매개변수와 지역 변수 선언문이 먼저 실행된다.
  - 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다.
- 지역 변수처럼 사용할 수 있는 `arguments` 객체가 생성되어 지역 스코프에 등록된다.
- `this` 바인딩도 결정된다.

### 4. 함수 코드 실행

- 함수 코드 평가 과정이 끝나면 런타임이 시작되어 함수 코드가 순차적으로 실행되기 시작한다.
- 매개변수와 지역 변수에 값이 할당되고 `console.log` 메서드가 호출된다.
  - 먼저 식별자인 `console`을 스코프 체인을 통해 검색한다.
  - 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다.
  - `console` 식별자는 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다.
- `log` 프로퍼티를 `console` 객체의 프로토타입 체인을 통해 검색한다.
- `console.log` 메서드에 인수로 전달된 표현식 `a + x + y`가 평가된다.
- `a + x + y`식별자는 스코프 체인을 통해 검색한다.

- 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 한다.
- 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 한다.
- 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야한다.
- 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.
- 이처럼 코드가 실행되러면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

### 이 모든 것을 관리하는 것이 바로 실행 컨텍스트다.

- 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
  - 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리
  - 스코프와 코드 실행 순서 관리
- 위 내용을 구현한 내부 매커니즘이다.
- 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
- 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리한다.
- 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.

### 실행 컨텍스트 vs 콜스택

> "실행 컨텍스트 스택"과 "콜 스택"은 사실상 동일한 개념을 참조합니다. 두 용어 모두 현재 실행 중인 함수의 컨텍스트를 추적하는 스택 구조를 나타냅니다.
>
> 자바스크립트는 함수를 호출할 때마다 해당 함수의 실행 컨텍스트를 생성하고 스택에 푸시합니다. 이 스택이 바로 "실행 컨텍스트 스택" 또는 "콜 스택"입니다. 각 실행 컨텍스트는 함수의 실행 상태, 변수, 객체, 함수 선언 등에 대한 정보를 포함합니다.
>
> 함수의 실행이 완료되면 해당 함수의 실행 컨텍스트는 스택에서 팝되어 제거됩니다. 이렇게 해서 현재 실행 중인 함수가 어떤 것인지, 그 함수가 어떤 함수에 의해 호출되었는지 등을 추적할 수 있습니다. 이와 같은 과정을 통해 자바스크립트 엔진은 코드의 실행 순서를 정확히 관리할 수 있습니다.
>
> 따라서, "실행 컨텍스트 스택"과 "콜 스택"은 같은 개념을 가리키며, 둘 사이에는 별다른 차이가 없습니다. 일반적으로 이 둘은 서로 바꿔서 사용될 수 있으며, 주로 자바스크립트의 실행 컨텍스트와 관련된 주제를 논의할 때 사용됩니다.

## 23.4 실행 컨텍스트 스택

```jsx
const x = 1

function foo() {
  const y = 2

  function bar() {
    const z = 3
    console.log(x + y + z)
  }

  bar()
}

foo()
```

<img width="588" alt="image" src="https://user-images.githubusercontent.com/88878874/255905097-c8e75bd6-4de3-4ad6-8d68-1f2d28b7198f.png">

1. 전역 코드의 평가와 실행
2. foo 함수 코드의 평가와 실행
3. bar 함수 코드의 평가와 실행
4. foo 함수 코드로 복귀
5. 전역 코드로 복귀

- 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.
- 스택의 최상위에 존재하는 실행 컨텍스트를 실행 중인 실행 실행 컨텍스트라 부른다.

## 23.5 렉시컬 환경

- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.
- 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.
- 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.
- 실행 컨텍스트는 아래 두 컴포넌트로 구성된다.
  - LexicalEnvironment
  - VariableEnvironment
- 렉시컬 환경은 다음과 같이 두 개의 컴포넌트로 구성된다.
  - Environment Record
    - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다.
  - Outer Lexical Environment Reference
    - 상위 스코프를 가리킨다.

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

### 23.6.1 전역 객체 생성

- 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
- 전역 객체
  - 빌트인 전역 프로퍼티
  - 빌트인 전역 함수
  - 표준 빌트인 객체
  - Web API
  - 호스트 객체
- 전역 객체도 `Object.prototype`을 상속받는다.
  - 전역 객체도 프로토타입 체인의 일원이다.

### 23.6.2 전역 코드 평가

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
   1. 전역 환경 레코드 생성
      1. 객체 환경 레코드 생성 - BindingObject: `var` 키워드로 선언한 전역 변수와 `함수 선언문`, 전역 객체
      2. 선언적 환경 레코드(개념적 블록) 생성 : `let`, `const` 키워드로 선언한 전역 변수
   2. this 바인딩 - `[ [GlobalTh i sValue] ]` 내부 슬롯
   3. 외부 렉시컬 환경에 대한 참조 결정: 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경

### 23.6.3 전역 코드 실행

- 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다.
  - 이를 식별자 결정이라 한다.
- 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다.
  - 검색할 수 없다면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 즉 상위 스코프로 이동하여 식별자를 검색한다.
- 전역 렉시컬 환경에서 검색할 수 없는 식별자는 참조 에러를 발생시킨다.

### 23.6.4 foo 함수 코드 평가

```jsx
var x = 1
const y = 2

function foo(a) {
  var x = 3
  const y = 4

  function bar(b) {
    const z = 5
    console.log(a + b + x + y + z)
  }

  bar(10)
}

foo(20)
```

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
   1. 함수 환경 레코드 생성: 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수
   2. this 바인딩: foo 함수는 일반 함수로 호출되었으므로전역 객체를 가리킨다.
   3. 외부 렉시컬 환경에 대한 참조 결정: `평가`된 시점에 `실행 중`인 실행 컨텍스트의 렉시컬 환경 참조가 할당된다.

### 23.6.5 foo 함수 코드 실행

- 식별자를 검색하기 시작한다.
- 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자를 검색한다.

### 렉시컬 환경의 소멸

- 실행 컨텍스트 스택에서 함수 실행 컨텍스트가 제거되었다고 해서 함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다.
- 렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 독립적인 객체다.
- 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸한다.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

- `var` 키워드로 선언한 변수는 `오로지 함수의 코드 블록`만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.
- `let`, `const` 키워드로 선언한 변수는 `모든 코드 블록`을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```jsx
let x = 1

if (true) {
  let x = 10
  console.log(x)
}

console.log(x)
```

- `if` 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
- 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.

<img width="804" alt="image" src="https://user-images.githubusercontent.com/88878874/255904932-a394374f-01ac-45c1-9149-f54fa0e8ff2f.png">

<img width="816" alt="image" src="https://user-images.githubusercontent.com/88878874/255904891-393c229a-206e-452a-b815-867d2fbf63c0.png">

- 이는 `if`문 뿐만 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용된다.
