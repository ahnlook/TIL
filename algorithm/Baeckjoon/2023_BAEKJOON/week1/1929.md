[문제 1929](https://www.acmicpc.net/problem/1929)

# 소수 구하기

## 문제

M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.

## 출력

한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

## 예제 입력

```
3 16
```

## 예제 출력

```
3
5
7
11
13
```

---

## ✏️ 문제 풀이

[(참고 블르그)](https://pannchat.tistory.com/entry/%EB%B0%B1%EC%A4%80-1929-nodejs-%EC%86%8C%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0)  
**소수** : 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수 (↔ 합성수)

### 에라토스테네스의 체

1. 찾고자 하는 범위의 자연수를 나열한다.
2. 1은 지운다.
3. 2부터 시작하여, 2의 배수를 지워나간다.
4. 다음 소수의 배수를 모두 지운다.

```
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString()
```

```
❌
const [num1, num2] = input.split(' ').map(Number)
const primeNum = []

for (let i = num1; i <= num2; i++) {
  if (i === 1) continue
  if (i % 2 === 0) continue
  for (let j = 3; j < i; j++) {
    if (i === j) continue
    if (i % j === 0) continue
    primeNum.push(i)
  }
}
```

에라토스테네스의 체를 활용해서 먼저 2의 배수는 합성수이기에 제외하고,

1. `i % 2`가 `0`일 경우 약수가 있고 소수라고 생각하고 풀었는데 자기 자신과 1로만 약수를 가지는 것을 고려하지 않았다.
2. 2중 for문으로 i를 j로 나누어 약수를 담는 배열을 만들었다. i의 약수가 3개 이상이면 합성수, 반복문을 다 돌았는데 약수가 2개(1과 자신)면 소수라고 생각했는데 문제가 풀리지 않았다.

구글링을 해보니 `num1`부터 `num1 제곱근`까지만 비교해야 시간 초과가 안 난다고 하여 시도해보자.

## 추가 풀이
